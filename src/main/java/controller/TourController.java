package controller;

import domain.AVL;
import domain.BST;
import domain.BTreeNode;
import domain.TreeException;
import javafx.fxml.FXML;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.*;
import util.FXUtil;

import static util.FXUtil.drawTreeNode;
import static util.Utility.Random;
import static util.Utility.random;

public class TourController {
    // contador para cada nodo
    private int counterTraversal;

    @FXML
    // donde se hace la creacion de lineas y ovals
    private Canvas treeCanvas;
    @FXML
    private Label label;

    @FXML
    private RadioButton rbAVL;

    @FXML
    private RadioButton rbBST;
    // acceso a clases
    private final BST bTree = new BST();
    private final AVL aTree = new AVL();

    private double zoomActual = 1.0;
    private double zoomStep = 0.1;// es el minimo antes que 0

    @FXML
    private ScrollPane scrollPane;

    @FXML
    public void initialize() {
        ToggleGroup group = new ToggleGroup();
        rbAVL.setToggleGroup(group);
        rbBST.setToggleGroup(group);

        treeCanvas.setOnScroll(event -> {
            if (event.isControlDown()) {
                if (event.getDeltaY() > 0) {
                    zoomActual += zoomStep;
                } else {
                    zoomActual -= zoomStep;
                }
                if (zoomActual < 0.1) zoomActual = 0.1;

                treeCanvas.setScaleX(zoomActual);
                treeCanvas.setScaleY(zoomActual);

                scrollPane.layout();
                event.consume();
            }
        });
    }

    @FXML

    public void handleRandomize() throws TreeException {
        randomize(30);
        label.setText("You have autogenerated a binary tree!");
        drawBTreeNodes();
    }

    //metodo para autogenerar numeros aleatorios
    private void randomize(int n) throws TreeException {
        //crea binary search tree
        if (rbBST.isSelected()){
                bTree.root = null;// cada vez pone la raiz en null
            for (int i = 0; i < n; i++) {
                int value = Random(0,50);
                bTree.add(value);
            }
            //crea un avl tree
        }else if (rbAVL.isSelected())
            aTree.root = null;// cada vez pone la raiz en null
        for (int i = 0; i < n; i++) {
            int value = random(100) + 1;
            aTree.add(value);
        }
    }
    // siempre counterTransversal en 1

    @FXML
    public void handlePreOrder() {
        counterTraversal = 1;
        //preorden del bst tree
        if (rbBST.isSelected()){
            recorridoPreOrderNumbers(bTree.root);
            label.setText("BST PreOrder Transversal Tour");
        }
        //preorden del  avl tree
        else if (rbAVL.isSelected()){
            recorridoPreOrderNumbers(aTree.root);
            label.setText("AVL PreOrder Transversal Tour");
        }

        drawBTreeNodes();
    }


    @FXML
    public void handleInOrder() {
        counterTraversal = 1;
        //inOrden del bst tree
        if (rbBST.isSelected()){
            recorridoInOrderNumbers(bTree.root);
            label.setText("BST InOrder Transversal Tour");
        }
        //inOorden del  avl tree
        else if (rbAVL.isSelected()){
            recorridoInOrderNumbers(aTree.root);
            label.setText("AVL InOrder Transversal Tour");
        }


        drawBTreeNodes();
    }

    @FXML
    public void handlePostOrder() {
        counterTraversal = 1;
        //preorden del bst tree
        if (rbBST.isSelected()){
            recorridoPostOrderNumbers(bTree.root);
            label.setText("BST PostOrder Transversal Tour");
        }
        //preorden del  avl tree
        else if (rbAVL.isSelected()){
            recorridoPostOrderNumbers(aTree.root);
            label.setText("AVL PostOrder Transversal Tour");
        }

        drawBTreeNodes();
    }


    // Por separado assign numbers
    // metodo que incremente el contador global, uso de recursividad como en clase
    // para ambos nodos left right
    // logica:
    // la forma en la que pongo el counterTransversal funciona para marcar el root
    // pre order primero counter-left-right

    private void recorridoPreOrderNumbers(BTreeNode node) {
        if (node == null) return;
        node.counterTranversal = counterTraversal++;
        recorridoPreOrderNumbers(node.left);
        recorridoPreOrderNumbers(node.right);
    }

    //left-root-right
    private void recorridoInOrderNumbers(BTreeNode node) {
        if (node == null) return;
        recorridoInOrderNumbers(node.left);
        node.counterTranversal = counterTraversal++;
        recorridoInOrderNumbers(node.right);
    }

    // left-right-root
    private void recorridoPostOrderNumbers(BTreeNode node) {
        if (node == null) return;
        recorridoPostOrderNumbers(node.left);
        recorridoPostOrderNumbers(node.right);
        node.counterTranversal = counterTraversal++;
    }

    private void drawBTreeNodes() {

        // graphicContext:forma de "dibujar" es como un objeto
        GraphicsContext treeGraphic = treeCanvas.getGraphicsContext2D();
        // 1.limpiar cada vez antes de entrar al if
        treeGraphic.clearRect(0, 0, treeCanvas.getWidth(), treeCanvas.getHeight());

        // bst tree
        if (rbBST.isSelected()){
            if (bTree.root != null) {// si hay raiz entonces permite llamar metodo drawBTreeNodes
                // getWidth()/2 para que se centrara el arbol
                drawTreeNode(treeGraphic, bTree.root, treeCanvas.getWidth() / 2, 40, treeCanvas.getWidth() / 4);
            }
        }
        //avl tree
        if (rbAVL.isSelected()){
            if (aTree.root != null) {// si hay raiz entonces permite llamar metodo drawBTreeNodes
                // getWidth()/2 para que se centrara el arbol
                aTree.leftRotate(aTree.root);
                drawTreeNode(treeGraphic, aTree.root, treeCanvas.getWidth() / 2, 40, treeCanvas.getWidth() / 4);
            }//parametros ( arbol, nodo( refere) , posicion del arbol x , posicion del arbol y , el espacio dispo)
            }

    }
}
